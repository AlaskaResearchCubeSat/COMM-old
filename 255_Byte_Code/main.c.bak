//Code for prototype Communication System for the Alaska Research CubeSat (ARC) as developed by the Alaska Space Grant Program
//Samuel Vanderwaal, APril 2012

#include <include.h>
#include <ctl_api.h>
#include "ARCbus.h"

//Create task structures
CTL_TASK_t tasks[2]; 

//Define stacks for tasks
unsigned stack1[1+256+1];
unsigned stack2[1+256+1];

void main(void)
{                                           
  // Sets up Timer A, clocks and pauses the watchdog timer
  ARC_setup();
  
  //Initialize UART
  initUART();                            
  
  // Initalizes bus interface
  initARCbus(BUS_ADDR_COMM);
  
  // Sets up the radio's SPI 
  SPI_Setup();               

  // Set up the GDO interrupts for the radios and also the output pins for PA switches, use with engineering board
  //radio_interrupts();

  Reset_Radios();                                                                   // Power up both radios
  Write_RF_Settings();                                                              // Write RF settings to config reg
  Radio_Write_Burst_Registers(TI_CCxxx0_PATABLE, paTable_CC1101, paTableLen, 1);    // Write PATABLE for CC1101
  Radio_Write_Burst_Registers(TI_CCxxx0_PATABLE, paTable_CC2500, paTableLen, 0);    // Write PATABLE for CC2500

  //Set up LEDs 1-8 for testing
  P7DIR |= BIT0;             
  P7DIR |= BIT1;
  P7DIR |= BIT2;
  P7DIR |= BIT3;
  P7DIR |= BIT4;
  P7DIR |= BIT5;
  P7DIR |= BIT6;
  P7DIR |= BIT7;            

  P7OUT = 0;
  
  //Enable interrupts on Port 2.0 - 2.3:
  //2.0 -- GDO0  CC1101
  //2.1 -- GDO2  CC1101
  //2.2 -- GDO0  CC2500
  //2.3 -- GDO2  CC2500
  P2DIR &= ~(BIT0 + BIT1 + BIT2 + BIT3);                                      
  P2IES &= ~(BIT0 + BIT1 + BIT2 + BIT3);    // Low-to-high transition for interrupts
  P2IE |= BIT0 + BIT1 + BIT2 + BIT3;        // Enable ints
  P2IFG = 0;                                // Clear flags

  Radio_Strobe(TI_CCxxx0_SRX, CC1101);           // Initialize CC1101 in RX mode
  Radio_Strobe(TI_CCxxx0_SRX, CC2500);           // Initialize CC2500 in Rx mode

  //Initialize stacks
  memset(stack1,0xcd,sizeof(stack1));   //Write known values into stack
  stack1[0] = stack1[sizeof(stack1)/sizeof(stack1[0]) - 1] = 0xfeed; //Create marker values at beginning and end of stack
  
  //Initialize stacks
  memset(stack2,0xcd,sizeof(stack2));  //Write known values into stack
  stack2[0] = stack2[sizeof(stack2)/sizeof(stack2[0]) - 1] = 0xfeed; //Create marker values at beginning and end of stack
  
  //Create tasks
  ctl_task_run(&tasks[0],10,TXRX,NULL,"TXRX",sizeof(stack1)/sizeof(stack1[0]) - 2,stack1+1,0);
  //ctl_taks_run(&tasks[1],1,name,NULL,"name",sizeof(stack2)/sizeof(stack2[0]) - 2,stack2+1,0);
  
  mainLoop();

  data_length = 255;
  // RxBufferLen = sizeof(RxBuffer);          // Length of packet to be received  This does not work for some reason

  RxThrBytes = 32;
  RxBufferLen = 255;
  temp_count1 = 0;
  temp_count2 = 0;
  P2IFG = 0;     // Clear flags
  _EINT();

  while (1){
  LPM0;


  switch (state){
      case TX_START:
          P2IE &= ~(BIT0 + BIT1 + BIT2 + BIT3);                                              // Disable Port 2 interrupts
          Radio_Write_Registers(TI_CCxxx0_IOCFG2, 0x02, uhf);                                // Set GDO2 to interrupt on FIFO thresholds
          P2IES |= (BIT0 + BIT1 + BIT2 + BIT3);                                              // Change edge interrupt happens on
          P2IFG = 0;                                                                         // Clear flags
          P2IE |= BIT0 + BIT1 + BIT2 + BIT3;                                                 // Enable Port 2 interrupts
          Build_Packet(data_length);
          if (TxBytesRemaining > 64)
          {
              count = 64;
              TxBytesRemaining = TxBytesRemaining - 64;
          }
          else
          {
              count = TxBytesRemaining;
              TxBytesRemaining = 0;
          }
          Radio_Write_Burst_Registers(TI_CCxxx0_TXFIFO, TxBuffer+TxBufferPos, count, uhf);     // Write TX data
          TxBufferPos += count;
          Radio_Strobe(TI_CCxxx0_STX, uhf);                                                  // Set radio state to Tx 
          break;

      case TX_RUNNING:
          if (TxBytesRemaining > 0) 
          {
             if (TxBytesRemaining > 30)
             {
                 count = 30;
                 TxBytesRemaining = TxBytesRemaining - 30;
             }
             else
             {
                 count = TxBytesRemaining;
                 TxBytesRemaining = 0;
             }
             Radio_Write_Burst_Registers(TI_CCxxx0_TXFIFO, TxBuffer + TxBufferPos, count, uhf);
             TxBufferPos += count;
          }
          if (TxBytesRemaining == 0)
          {
              state = 0;
              if (uhf)
              {
                  P7OUT ^= BIT0;
                  temp_count1++;
                  printf("%d", temp_count1);
                  printf(" packet(s) sent \r\n");
                  printf("CC1101 \r\n");
//                  printf("packet sent \r\n");
//                  for (k=0; k < TxBufferPos; k++)
//                 {
//                     printf("%d ", TxBuffer[k]);
//                     printf(" ");
//                 }
              }
              if (!(uhf))
              {
                  P7OUT ^= BIT4;
                  temp_count2++;
                  printf("%d", temp_count2);
                  printf(" packet(s) sent \r\n");
                  printf("CC2500 \r\n");
//                  printf("packet sent \r\n");
//                  for (k=0; k < TxBufferPos; k++)
//                 {
//                     printf("%d ", TxBuffer[k]);
//                     printf(" ");
//                 }
              }
              P2IE &= ~(BIT0 + BIT1 + BIT2 + BIT3);                                              // Disable Port 2 interrupts
              Radio_Write_Registers(TI_CCxxx0_IOCFG2, 0x00, uhf);                                // Set GDO2 to interrupt on FIFO thresholds
              P2IES &= ~(BIT0 + BIT1 + BIT2 + BIT3);                                              // Change edge interrupt happens on
              P2IFG = 0;                                                                         // Clear flags
              P2IE |= BIT0 + BIT1 + BIT2 + BIT3; 
          }

          break;

      case RX_START:                                  
          RxFIFOLen = (Radio_Read_Status(TI_CCxxx0_RXBYTES, uhf) & TI_CCxxx0_NUM_RXBYTES);
          //if (RF_Receive_Packet(RxBuffer, &RxBufferLen, CC1101))       // Get packet from CC1101
          PktLen = 255; //Radio_Read_Registers(TI_CCxxx0_RXFIFO, CC1101);       // Read length byte
          RxBytesRemaining = PktLen;                                  // Set number of bytes left to receive
          Radio_Read_Burst_Registers(TI_CCxxx0_RXFIFO, RxBuffer+RxBufferPos, RxFIFOLen, uhf);
          RxBufferPos += RxFIFOLen;
          RxBytesRemaining -= RxFIFOLen;
          break;

      case RX_RUNNING:
           if (RxBytesRemaining > 0)
           {
               if (RxBytesRemaining > RxThrBytes)
               {
                   count = RxThrBytes;
                   RxBytesRemaining = RxBytesRemaining - RxThrBytes;
                   temp_count1++;
               }
               else 
               {
                   count = RxBytesRemaining;
                   RxBytesRemaining = 0;
               }
               Radio_Read_Burst_Registers(TI_CCxxx0_RXFIFO, RxBuffer+RxBufferPos, count, uhf);
               RxBufferPos += count;
           }
           if (RxBytesRemaining == 0)
           {
                 if (uhf) 
                 {
                     state = 0;
                     P7OUT ^= BIT1;
                     printf("receiving packet\r\n");
                     printf("\r\n");
                     for (k=0; k < PktLen; k++)
                     {
                         printf("%d ", RxBuffer[k]);
                         printf("\r\n");
                     }
                 }

                 if (!(uhf))
                 {
                     state = 0;
                     P7OUT ^= BIT5;
                     printf("receiving packet\r\n");
                     for (k=0; k < PktLen; k++)
                     {
                         printf("%d ", RxBuffer[k]);
                         printf("\r\n");
                     }
                 }
           }                         
          break;
      
      default:
          break;
  }
  }
}
                     
#pragma vector=PORT2_VECTOR
__interrupt void port2_ISR (void)
{
   if (P2IFG & BIT0)
    {
        switch(state){
            case IDLE:
                 /*
                 P2IE &= ~(BIT0 + BIT1 + BIT2 + BIT3);                       // Disable Port 2 interrupts
                 Radio_Write_Registers(TI_CCxxx0_IOCFG2, 0x00, uhf);
                 P2IES &= ~(BIT0 + BIT1 + BIT2 + BIT3);                      // Change edge interrupt happens on
                 P2IFG = 0;                                                  // Clear flags
                 P2IE |= BIT0 + BIT1 + BIT2 + BIT3;                          // Enable Port 2 interrupts   
                 */
                 RxBufferPos = 0;
                 break;

            case TX_START:
                 P2IFG &= ~BIT0;
                 break;

            case RX_START:
                 break;

                     }
    } 

    if (P2IFG & BIT1) 
    {
        switch(state)
        {
            case IDLE:
                 state = RX_START;
                 break;

            case TX_START:
                 state = TX_RUNNING;
                 break;

            case RX_START:
                 state = RX_RUNNING;
                 break;

        }
                 
        uhf = 1;
        P2IFG &= ~BIT1;
    }
  
   if (P2IFG & BIT2)
    {
        if (state == TX_START)
        { 
            P2IFG &= ~BIT2;
        }
        else
        {
            state = RX_START;
            RxBufferPos = 0;
            uhf = 0;
            P2IFG &= ~BIT2;                           // Clear flag
        }

    } 

    if (P2IFG & BIT3) 
    {
      if (state == TX_START)
          state = TX_RUNNING;

      if (state == RX_START)
          state = RX_RUNNING;

      uhf = 0;
      P2IFG &= ~BIT3;
    }
P2IFG = 0;
LPM0_EXIT;
}
